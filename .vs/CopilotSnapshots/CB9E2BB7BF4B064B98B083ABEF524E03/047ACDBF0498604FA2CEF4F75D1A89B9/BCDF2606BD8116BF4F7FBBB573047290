using System;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text.RegularExpressions;

namespace DCM.Core.Utilities
{
    /// <summary>
    /// Representa um prefixo válido para nome de computador como objeto de valor.
    /// Usado para categorizar tipos de dispositivos (ex: "KIOSK", "DSKTP", "NOTBK", "TABLT", "SERVR", "VM").
    /// </summary>
    public sealed class PrefixComputerName
    {
        /// <summary>
        /// Valor do prefixo para ComputerName.
        /// Deve ter no máximo 5 caracteres, conter apenas letras maiúsculas e números.
        /// </summary>
        [Required, StringLength(5)]
        public string Value { get; }

        /// <summary>
        /// Prefixos válidos predefinidos para diferentes tipos de dispositivos.
        /// </summary>
        public static readonly string[] ValidPrefixes = 
        {
            "KIOSK",   // Kiosks e terminais de autoatendimento
            "DSKTP",   // Computadores desktop
            "NOTBK",   // Notebooks e laptops
            "TABLT",   // Tablets
            "SERVR",   // Servidores
            "VM",      // Máquinas virtuais
            "PRINT",   // Impressoras de rede
            "THIN",    // Thin clients
            "AIO"      // All-in-One
        };

        /// <summary>
        /// Construtor padrão privado para o Entity Framework Core.
        /// </summary>
        private PrefixComputerName() 
        {
            Value = string.Empty;
        }

        /// <summary>
        /// Cria uma nova instância de PrefixComputerName com validação.
        /// </summary>
        /// <param name="prefix">Prefixo do nome do computador</param>
        /// <exception cref="ArgumentException">Lançado quando o prefixo é inválido</exception>
        public PrefixComputerName(string prefix)
        {
            if (string.IsNullOrWhiteSpace(prefix))
                throw new ArgumentException("Prefixo não pode ser vazio ou nulo.", nameof(prefix));

            var normalizedPrefix = prefix.Trim().ToUpperInvariant();

            if (normalizedPrefix.Length > 5)
                throw new ArgumentException("Prefixo não pode ter mais de 5 caracteres.", nameof(prefix));

            if (!Regex.IsMatch(normalizedPrefix, @"^[A-Z]+$"))
                throw new ArgumentException("Prefixo deve conter apenas letras maiúsculas.", nameof(prefix));

            Value = normalizedPrefix;
        }

        /// <summary>
        /// Cria um PrefixComputerName a partir de um prefixo predefinido válido.
        /// </summary>
        /// <param name="validPrefix">Um dos prefixos válidos da lista ValidPrefixes</param>
        /// <returns>Nova instância de PrefixComputerName</returns>
        /// <exception cref="ArgumentException">Lançado quando o prefixo não está na lista de válidos</exception>
        public static PrefixComputerName FromValidPrefix(string validPrefix)
        {
            if (string.IsNullOrWhiteSpace(validPrefix))
                throw new ArgumentException("Prefixo não pode ser vazio ou nulo.", nameof(validPrefix));

            var normalizedPrefix = validPrefix.Trim().ToUpperInvariant();

            if (!ValidPrefixes.Contains(normalizedPrefix))
                throw new ArgumentException($"Prefixo '{validPrefix}' não está na lista de prefixos válidos: {string.Join(", ", ValidPrefixes)}", nameof(validPrefix));

            return new PrefixComputerName(normalizedPrefix);
        }

        /// <summary>
        /// Verifica se um prefixo está na lista de prefixos válidos predefinidos.
        /// </summary>
        /// <param name="prefix">Prefixo a ser verificado</param>
        /// <returns>True se o prefixo for válido, false caso contrário</returns>
        public static bool IsValidPrefix(string prefix)
        {
            if (string.IsNullOrWhiteSpace(prefix))
                return false;

            return ValidPrefixes.Contains(prefix.Trim().ToUpperInvariant());
        }

        /// <summary>
        /// Obtém a descrição do tipo de dispositivo baseado no prefixo.
        /// </summary>
        /// <returns>Descrição do tipo de dispositivo</returns>
        public string GetDeviceTypeDescription()
        {
            return Value switch
            {
                "KIOSK" => "Kiosk/Terminal de Autoatendimento",
                "DSKTP" => "Computador Desktop",
                "NOTBK" => "Notebook/Laptop",
                "TABLT" => "Tablet",
                "SERVR" => "Servidor",
                "VRTLM" => "Máquina Virtual",
                "THINC" => "Thin Client",
                "ALLIO" => "All-in-One",
                "WORKT" => "Estação de Trabalho",
                _ => "Tipo Desconhecido"
            };
        }

        /// <summary>
        /// Converte implicitamente uma string para PrefixComputerName.
        /// </summary>
        /// <param name="prefix">String do prefixo</param>
        public static implicit operator PrefixComputerName(string prefix)
        {
            return new PrefixComputerName(prefix);
        }

        /// <summary>
        /// Converte implicitamente PrefixComputerName para string.
        /// </summary>
        /// <param name="prefixComputerName">Instância de PrefixComputerName</param>
        public static implicit operator string(PrefixComputerName prefixComputerName)
        {
            return prefixComputerName?.Value ?? string.Empty;
        }

        /// <summary>
        /// Retorna a representação em string do prefixo.
        /// </summary>
        /// <returns>Valor do prefixo</returns>
        public override string ToString() => Value;

        /// <summary>
        /// Verifica a igualdade entre duas instâncias de PrefixComputerName.
        /// </summary>
        /// <param name="obj">Objeto a ser comparado</param>
        /// <returns>True se os objetos forem iguais, false caso contrário</returns>
        public override bool Equals(object? obj)
        {
            return obj is PrefixComputerName other && Value == other.Value;
        }

        /// <summary>
        /// Obtém o código hash da instância.
        /// </summary>
        /// <returns>Código hash baseado no valor do prefixo</returns>
        public override int GetHashCode() => Value?.GetHashCode() ?? 0;

        /// <summary>
        /// Operador de igualdade entre duas instâncias de PrefixComputerName.
        /// </summary>
        public static bool operator ==(PrefixComputerName? left, PrefixComputerName? right)
        {
            return left?.Value == right?.Value;
        }

        /// <summary>
        /// Operador de desigualdade entre duas instâncias de PrefixComputerName.
        /// </summary>
        public static bool operator !=(PrefixComputerName? left, PrefixComputerName? right)
        {
            return !(left == right);
        }
    }
}
